<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器内核详解</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="内核介绍以及以Chrome为例的内核渲染讲解">
    <meta name="keywords" content="浏览器内核详解">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.2f811b15.js" as="script"><link rel="preload" href="/assets/js/2.4aba836d.js" as="script"><link rel="preload" href="/assets/js/8.43fbb25c.js" as="script"><link rel="prefetch" href="/assets/js/10.3dbdad0d.js"><link rel="prefetch" href="/assets/js/11.0be346e2.js"><link rel="prefetch" href="/assets/js/3.a58a7520.js"><link rel="prefetch" href="/assets/js/4.ba3164ba.js"><link rel="prefetch" href="/assets/js/5.75a3592b.js"><link rel="prefetch" href="/assets/js/6.0377ba0c.js"><link rel="prefetch" href="/assets/js/7.792231a2.js"><link rel="prefetch" href="/assets/js/9.3d6b8fa8.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器内核详解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#什么是浏览器内核" class="sidebar-link">什么是浏览器内核？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#浏览器的组成部分" class="sidebar-link">浏览器的组成部分</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#各浏览器对应内核" class="sidebar-link">各浏览器对应内核</a></li></ul></li><li><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#以chrome为例介绍浏览器运行" class="sidebar-link">以Chrome为例介绍浏览器运行</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#浏览器进程介绍" class="sidebar-link">浏览器进程介绍</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#chrome四种进程模型" class="sidebar-link">Chrome四种进程模型：</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#当你在浏览器地址栏输入网址" class="sidebar-link">当你在浏览器地址栏输入网址</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#浏览器进程" class="sidebar-link">浏览器进程</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#渲染器进程" class="sidebar-link">渲染器进程</a></li><li class="sidebar-sub-header"><a href="/ChromeCore/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8.html#html渲染主要步骤" class="sidebar-link">HTML渲染主要步骤：</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><em>本文博客地址<a href="https://laocuicode.cn/daydream/2021/07/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/" target="_blank" rel="noopener noreferrer">老崔的小破栈<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></em></p> <h2 id="什么是浏览器内核"><a href="#什么是浏览器内核" class="header-anchor">#</a> 什么是浏览器内核？</h2> <blockquote><p>一般我们常说的浏览器内核指的其实就是“渲染引擎”</p></blockquote> <h3 id="浏览器的组成部分"><a href="#浏览器的组成部分" class="header-anchor">#</a> 浏览器的组成部分</h3> <blockquote><p>浏览器的组成主要有三部分：用户界面，浏览器引擎以及渲染引擎</p></blockquote> <p><strong>用户界面</strong>：这个其实就是我们平常使用浏览器看到的一部分</p> <p><strong>浏览器引擎</strong>：用于在用户界面和渲染引擎之间传递数据（一般来说这就是浏览器的数据持久层）</p> <p><strong>渲染引擎</strong>：负责渲染用户请求的页面内容</p> <ul><li><p>渲染引擎包括多个小的功能模块如：</p> <p><code>网络模块</code>：负责网络请求</p> <p><code>JS解析器</code>：用于解析和执行JS</p></li></ul> <h1 id="常见浏览器内核以及其发展史"><a href="#常见浏览器内核以及其发展史" class="header-anchor">#</a> 常见浏览器内核以及其发展史</h1> <blockquote><p>这部分就比较生硬了，貌似所有介绍者都喜欢介绍这部分</p></blockquote> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="image-20210706125850018"></p> <p><em>上图截取自油管视频主Luke Lee的视频</em></p> <ul><li>1991年<code>Berners Lee</code>建立了第一代浏览器<code>World Wide Web</code></li></ul> <blockquote><p>Berners Lee是互联网发明者之一（妥妥的大佬）</p> <p>World Wide Web 只支持显示图片和文本</p></blockquote> <ul><li>1993年<code>Mosaic</code>问世</li></ul> <blockquote><p>Mosaic可以同时显示文本和图片</p></blockquote> <ul><li>1994年<code>网景</code>,<code>OPERA</code>发布</li></ul> <blockquote><p>网景的开发人员有一部分曾参与Mosaic开发</p> <p>只能显示HTML没有CSS和JS</p> <p>相较于网景，opera使用较少</p></blockquote> <ul><li>1995年<code>IE</code>诞生</li></ul> <blockquote><p>万恶之源？自此第一次浏览器大战正式打响</p></blockquote> <ul><li>1996年<code>IE3.0</code>发布且与windows融合</li></ul> <blockquote><p>此时网景的市场份额仍有86%</p></blockquote> <ul><li>1998年<code>网景</code>公司成立Mozilla基金会</li></ul> <blockquote><p>基金会用来开发火狐浏览器</p></blockquote> <ul><li>1999年<code>IE</code>占据99%市场</li></ul> <blockquote><p>牛哇</p></blockquote> <ul><li>2003年<code>Safari</code>浏览器问世</li></ul> <blockquote><p>觉得眼熟？这就是苹果专用浏览器</p></blockquote> <ul><li>2004年<code>Firefox(火狐)</code>问世</li></ul> <blockquote><p>第二次浏览器大战序幕拉开</p></blockquote> <ul><li>2005年苹果公司将<code>webkit</code>内核开源</li></ul> <blockquote><p>为浏览器发展贡献巨大，开源yyds</p></blockquote> <ul><li>2008年<code>google</code>以<code>webkit</code>为核心开发<code>chrome</code>和<code>chromium</code></li></ul> <blockquote><p>最强浏览器诞生？</p></blockquote> <ul><li>2015年微软推出以<code>webkit</code>为内核的浏览器<code>edge</code></li></ul> <blockquote><p>来晚咯</p></blockquote> <h3 id="各浏览器对应内核"><a href="#各浏览器对应内核" class="header-anchor">#</a> 各浏览器对应内核</h3> <p><code>IE</code>: Trident</p> <p><code>FireFox</code>: Gecko</p> <p><code>Safari</code>: Webkit</p> <p><code>Chrome</code>,<code>Opera</code>,<code>Edge</code>: Blink(基于Webkit开发的)</p> <h2 id="以chrome为例介绍浏览器运行"><a href="#以chrome为例介绍浏览器运行" class="header-anchor">#</a> 以Chrome为例介绍浏览器运行</h2> <p>本质：浏览器本质上是运行在操作系统上的一个应用程序</p> <blockquote><p>应用程序的特征：每个应用程序至少启动一个进程来执行功能</p> <p>进程执行过程中由于有许多任务所以会创建线程来帮助执行</p></blockquote> <p><strong>进程</strong>：是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体</p> <p><strong>线程</strong>：线程是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p> <p><strong>通俗点讲</strong>：应用程序启动后会创建多个进程。各个进程之间的内存空间不同，因此相互独立，进程之间通信需要通过<code>进程间通信管道IPC</code>来实现，每个进程可以将任务分成更多细小的人物，并通过创建多个线程<code>并行</code>执行不同的任务，同一进程下的线程是可以直接通信共享数据的</p> <h3 id="浏览器进程介绍"><a href="#浏览器进程介绍" class="header-anchor">#</a> 浏览器进程介绍</h3> <p><strong>早期浏览器使用单进程</strong>：</p> <ul><li>不稳定：其中一个线程的卡死会导致整个进程卡死</li> <li>不安全：由于同一进程下的线程可以共享数据，js线程可以直接访问浏览器进程内的所有数据</li> <li>不流畅：一个进程需要负责太多事情会导致运行效率问题</li></ul> <p><strong>现代浏览器使用多进程</strong>：</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%93%E6%9E%84.png" alt="image-20210706133613130"></p> <p><strong>浏览器进程</strong>：负责控制Chrome浏览器除标签页外的用户页面包括地址栏，书签，后退和前进按钮以及负责与浏览器的其他进程协调工作</p> <p><strong>网络进程</strong>：负责发起/接受网络请求</p> <p><strong>GPU进程</strong>：负责整个浏览器界面的渲染</p> <p><strong>插件进程</strong>：负责控制网站使用的所有插件（如flash等）</p> <p><strong>渲染器进程</strong>：用来控制显示tab标签内的所有内容</p> <blockquote><p>浏览器在默认情况下会为每个标签页创建一个渲染器进程，这个操作与你启动Chrome时选择的进程模型有关</p></blockquote> <h3 id="chrome四种进程模型"><a href="#chrome四种进程模型" class="header-anchor">#</a> Chrome四种进程模型：</h3> <ul><li>process-per-site-instance(default)：为用户访问的每个实例创建一个渲染器进程，这样可以确保来自不同站点的页面是独立呈现的，并且对同一站点的单独访问也是彼此隔离的，<strong>简单来说就是访问不同站点或者访问同一站点的不同页面都会产生新的进程</strong></li> <li>process-per-site：同一站点使用同一进程</li> <li>process-per-tab：一个tab里的所有站点使用同一个进程</li> <li>single-process：让浏览器引擎和渲染引擎共用一个进程</li></ul> <h3 id="当你在浏览器地址栏输入网址"><a href="#当你在浏览器地址栏输入网址" class="header-anchor">#</a> 当你在浏览器地址栏输入网址</h3> <p>你知道当你在浏览器地址栏输入网址时，你的浏览器会做什么嘛：</p> <h3 id="浏览器进程"><a href="#浏览器进程" class="header-anchor">#</a> 浏览器进程</h3> <ul><li><p>首先，浏览器进程的UI会捕捉输入内容：</p> <ul><li>如果访问的是网址，则UI线程会启动一个网络线程来请求DNS域名解析，接着开始连接服务器获取数据</li> <li>如果输入的是一串关键词，浏览器会使用默认配置的搜索引擎来查询</li></ul></li> <li><p>网络线程获取到数据之后：</p> <p>当网络线程获取的数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是则会提示警告，当然你也可以强制访问</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E8%AE%BF%E9%97%AE.png" alt="image-20210706135600907"></p> <blockquote><p>SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全，比如查看IP是否在谷歌黑名单中</p></blockquote> <p>当返回数据准备完毕并通过安全检验时，网络线程会通知UI线程，UI线程会创建一个渲染器进程来渲染页面，浏览器进程通过ICP将页面数据传递给渲染器进程</p></li></ul> <h3 id="渲染器进程"><a href="#渲染器进程" class="header-anchor">#</a> 渲染器进程</h3> <ul><li>渲染器进程接受到数据（HTML等），</li> <li>核心任务是：html，css，js，image等资源渲染成用户可以交互的web页面</li> <li>渲染器进程的主线程将html进行解析构造DOM数据结构</li></ul> <blockquote><p>DOM（文档对象数据模型）是浏览器对页面在其内部的表示形式。是程序员通过js可与之交互的数据结构和API</p></blockquote> <h3 id="html渲染主要步骤"><a href="#html渲染主要步骤" class="header-anchor">#</a> HTML渲染主要步骤：</h3> <p><strong>Html的解析主要包括两个部分</strong></p> <ol><li><p><em>Tokeniser阶段</em></p> <p>通过词法分析将HTML解析为多个标记
这是一个基于事件的HTML文本解析过程，最后会生成一个Token序列输出，当然此过程中来自网络的HTML不一定是整个文档，网络端接收到一部分HTML字节流时就会通知解析机解析该部分的内容。</p></li> <li><p><em>TreeConstruction阶段</em></p> <p>根据识别后的标记进行DOM树构造
Tokeniser阶段的Token序列产生后，就会把序列一个一个地输入到TreeConstruction中，最后输出DOMTree。</p></li></ol> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/HTML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="image-20210706141138135"></p> <blockquote><p>HTML解析过程中的几个重要点：</p> <ol><li>CSS,image等静态资源需要从网络/本地存储中获取，这些资源加载不会阻塞html的解析</li> <li>JS执行会阻塞html解析，其原因是浏览器无法确认js是否会改变dom结构，因此遇到script标签会直接执行，所以我们需要使用async或者defer属性异步加载js</li></ol></blockquote> <ul><li><p>主线程解析完HTML后开始解析CSS（默认CSS或自定义CSS）</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/CSS%E6%B8%B2%E6%9F%93.png" alt="image-20210706141659015"></p></li> <li><p>主线程解析完CSS后要确定元素在页面的位置。这个过程被称作<code>layout</code>布局</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layout%E5%B8%83%E5%B1%80%EF%BC%881%EF%BC%89.png" alt="image-20210706141905267"></p></li> <li><p>主线程通过遍历dom和计算好的样式来生成<code>layout tree</code>：</p></li></ul> <p>![image-20210706142031568](https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layout tree.png)</p> <blockquote><p>dom tree和layout tree不是一一对应的，设置了<code>display:none</code>的dom节点不会出现在layout tree上</p> <p>在<code>before伪类</code>中添加了<code>content</code>值的元素，content里的内容会出现在layout tree上，不会出现在dom树里，这是因为dom tree是通过HTML解析获得，并不关心样式，而layout tree则是根据DOM和计算好的样式来生成</p></blockquote> <ul><li><p>接下来主线程需要确定以什么样的顺序绘制节点</p></li> <li><p>主线程遍历layout tree创建绘制记录表（Paint Record），该表记录了绘制的顺序（这个阶段被称为绘制）</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E7%BB%98%E5%88%B6%E9%A1%BA%E5%BA%8F%E8%A1%A8.png" alt="image-20210706142812893"></p></li> <li><p>现在一切准备就绪，到了将这些信息转化为像素点显示到屏幕上的时候了，这个行为叫做<strong>栅格化(Rastering)</strong></p> <ul><li>早期Chrome使用极其简单的方式进行栅格化，即只栅格化用户可见区域的内容，造成的缺点就是展示延迟（当你向下滚动时要等待页面加载）</li> <li>而现在Chrome采用更为复杂的栅格化方式：<strong>合成(Compositing)</strong>：将页面的多个部分分成多个图层，分别对其进行栅格化，并在合成器线程(Compositor Thread)中单独进行合成页面的技术，简单来说就是页面所有的元素按照某种规则进行分图层并把图层都栅格化好了，然后只需要把可视区域的内容组合成一帧展示给用户即可</li></ul> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/Chrome%E6%A0%85%E6%A0%BC%E5%8C%96%E6%96%B9%E6%B3%95.png" alt="image-20210706143311472"></p></li> <li><p>主线程遍历layout tree生成layer(图层) tree，当layer tree生成完毕和绘制顺序确定后</p> <p>![image-20210706143811820](https://chqosssave.oss-cn-beijing.aliyuncs.com/img/layer tree.png)</p></li> <li><p>主线程将这些信息传递给合成器线程，合成器线程将每个图层栅格化，合成器会将一个大页面分割成许多图块(tiles)，然后将每个图块发送给栅格化线程</p></li> <li><p>栅格线程栅格每个图块，并将它们存储在GPU内存中</p></li> <li><p>在栅格化线程结束后，合成器线程会收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面哪个位置绘制图块的信息</p></li> <li><p>根据这些信息合成器线程生成了一个合成器帧(Compositor Frame)</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E5%90%88%E6%88%90%E5%99%A8%E5%B8%A7.png" alt="image-20210706144501182"></p></li> <li><p>然后合成器帧通过IPC传送给浏览器进程，浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上（页面渲染完成）</p></li> <li><p>当页面滚动发生变化，则会生成新的合成器帧让后继续上述步骤</p></li> <li><p>总流程如下：</p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B%E6%A6%82%E6%8B%AC.png" alt="image-20210706144908915"></p></li> <li><p>当排版发生改变，我们会重复上图过程，这个过程我们称为<strong>重排</strong></p></li> <li><p>当我们改变某个元素的颜色属性时，不会触发重排，但是会触发样式的计算和绘制，这个过程称为<strong>重绘</strong></p> <blockquote><p>重排和重绘都会占用主线程，而js也会占用主线程，当页面以60帧每秒（也就是每帧16ms）的刷新率时，用户才不会觉得卡顿，当页面在一帧的时间内布局和绘制结束后还有剩余时间，JS会获得主线程的使用权，如果JS执行时间过长就会导致下一帧开始时JS没有及时归还主线程，导致下一帧动画没有进行渲染，就会出现页面动画卡顿</p></blockquote></li> <li><p>优化手段：</p> <ul><li><p>通过requestAnimationFrame()来处理：</p> <p>这个方法会在每一帧被调用，我们可以将js任务分为更小的任务块，在每一帧时间用完前暂停js执行归还主线程</p></li></ul> <blockquote><p>React 最新的渲染引擎React fiber就用到这个API做了大量优化</p></blockquote> <ul><li>CSS中有个动画属性叫做<code>transform</code>通过该属性实现动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，不会占用主线程，更不会收到主线程中JS的影响</li></ul> <blockquote><p>另外，transform动画由于不需要经过布局绘制，样式计算等操作，可以节省大量运算时间（方便实现动画）</p></blockquote> <p><strong>transform动画取代原有动画实现</strong></p> <p><img src="https://chqosssave.oss-cn-beijing.aliyuncs.com/img/transform%E4%BB%A3%E6%9B%BF%E5%8A%A8%E7%94%BB.png" alt="image-20210706150318559"></p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2f811b15.js" defer></script><script src="/assets/js/2.4aba836d.js" defer></script><script src="/assets/js/8.43fbb25c.js" defer></script>
  </body>
</html>
